/*
 * Copyright (C) 2018 by Slava Monich
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1.Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   2.Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer
 *     in the documentation and/or other materials provided with the
 *     distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING
 * IN ANY WAY OUT OF THE USE OR INABILITY TO USE THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * any official policies, either expressed or implied.
 */

#include "test_common.h"

#include "foil_hmac.h"
#include "foil_digest.h"

typedef struct test_hmac {
    const char* name;
    GType (*digest_type)(void);
    FoilBytes key;
    FoilBytes data;
    FoilBytes output;
} TestHmac;

/*
 * Test vectors from:
 *
 * https://tools.ietf.org/rfc/rfc2202.txt (MD-5, SHA-1)
 * https://tools.ietf.org/rfc/rfc2202.txt (SHA-256)
 */

#define test1_sha256_key test1_sha1_key
#define test1_md5_data test1_data
#define test1_sha1_data test1_data
#define test1_sha256_data test1_data
static const guint8 test1_md5_key[] = {
    0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
    0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b
};
static const guint8 test1_sha1_key[] = {
    0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
    0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
    0x0b,0x0b,0x0b,0x0b
};
static const guint8 test1_data[] = {
    'H', 'i', ' ', 'T', 'h', 'e', 'r', 'e'
};
static const guint8 test1_md5_output[] = {
    0x92,0x94,0x72,0x7a,0x36,0x38,0xbb,0x1c,
    0x13,0xf4,0x8e,0xf8,0x15,0x8b,0xfc,0x9d
};
static const guint8 test1_sha1_output[] = {
    0xb6,0x17,0x31,0x86,0x55,0x05,0x72,0x64,
    0xe2,0x8b,0xc0,0xb6,0xfb,0x37,0x8c,0x8e,
    0xf1,0x46,0xbe,0x00
};
static const guint8 test1_sha256_output[] = {
    0xb0,0x34,0x4c,0x61,0xd8,0xdb,0x38,0x53,
    0x5c,0xa8,0xaf,0xce,0xaf,0x0b,0xf1,0x2b,
    0x88,0x1d,0xc2,0x00,0xc9,0x83,0x3d,0xa7,
    0x26,0xe9,0x37,0x6c,0x2e,0x32,0xcf,0xf7
};

#define test2_md5_key test2_key
#define test2_sha1_key test2_key
#define test2_sha256_key test2_key
#define test2_md5_data test2_data
#define test2_sha1_data test2_data
#define test2_sha256_data test2_data
static const guint8 test2_key[] = {
    'J', 'e', 'f', 'e'
};
static const guint8 test2_data[] = {
    'w', 'h', 'a', 't', ' ', 'd', 'o', ' ',
    'y', 'a', ' ', 'w', 'a', 'n', 't', ' ',
    'f', 'o', 'r', ' ', 'n', 'o', 't', 'h',
    'i', 'n', 'g', '?'
};
static const guint8 test2_md5_output[] = {
    0x75,0x0c,0x78,0x3e,0x6a,0xb0,0xb5,0x03,
    0xea,0xa8,0x6e,0x31,0x0a,0x5d,0xb7,0x38
};
static const guint8 test2_sha1_output[] = {
    0xef,0xfc,0xdf,0x6a,0xe5,0xeb,0x2f,0xa2,
    0xd2,0x74,0x16,0xd5,0xf1,0x84,0xdf,0x9c,
    0x25,0x9a,0x7c,0x79
};
static const guint8 test2_sha256_output[] = {
    0x5b,0xdc,0xc1,0x46,0xbf,0x60,0x75,0x4e,
    0x6a,0x04,0x24,0x26,0x08,0x95,0x75,0xc7,
    0x5a,0x00,0x3f,0x08,0x9d,0x27,0x39,0x83,
    0x9d,0xec,0x58,0xb9,0x64,0xec,0x38,0x43
};

#define test3_sha256_key test3_sha1_key
#define test3_md5_data test3_data
#define test3_sha1_data test3_data
#define test3_sha256_data test3_data
static const guint8 test3_md5_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa
};
static const guint8 test3_sha1_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa
};
static const guint8 test3_data[] = {
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
    0xdd,0xdd
};
static const guint8 test3_md5_output[] = {
    0x56,0xbe,0x34,0x52,0x1d,0x14,0x4c,0x88,
    0xdb,0xb8,0xc7,0x33,0xf0,0xe8,0xb3,0xf6
};
static const guint8 test3_sha1_output[] = {
    0x12,0x5d,0x73,0x42,0xb9,0xac,0x11,0xcd,
    0x91,0xa3,0x9a,0xf4,0x8a,0xa1,0x7b,0x4f,
    0x63,0xf1,0x75,0xd3
};
static const guint8 test3_sha256_output[] = {
    0x77,0x3e,0xa9,0x1e,0x36,0x80,0x0e,0x46,
    0x85,0x4d,0xb8,0xeb,0xd0,0x91,0x81,0xa7,
    0x29,0x59,0x09,0x8b,0x3e,0xf8,0xc1,0x22,
    0xd9,0x63,0x55,0x14,0xce,0xd5,0x65,0xfe
};

#define test4_md5_key test4_key
#define test4_sha1_key test4_key
#define test4_sha256_key test4_key
#define test4_md5_data test4_data
#define test4_sha1_data test4_data
#define test4_sha256_data test4_data
static const guint8 test4_key[] = {
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
    0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
    0x19
};
static const guint8 test4_data[] = {
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
    0xcd,0xcd
};
static const guint8 test4_md5_output[] = {
    0x69,0x7e,0xaf,0x0a,0xca,0x3a,0x3a,0xea,
    0x3a,0x75,0x16,0x47,0x46,0xff,0xaa,0x79
};
static const guint8 test4_sha1_output[] = {
    0x4c,0x90,0x07,0xf4,0x02,0x62,0x50,0xc6,
    0xbc,0x84,0x14,0xf9,0xbf,0x50,0xc8,0x6c,
    0x2d,0x72,0x35,0xda
};
static const guint8 test4_sha256_output[] = {
    0x82,0x55,0x8a,0x38,0x9a,0x44,0x3c,0x0e,
    0xa4,0xcc,0x81,0x98,0x99,0xf2,0x08,0x3a,
    0x85,0xf0,0xfa,0xa3,0xe5,0x78,0xf8,0x07,
    0x7a,0x2e,0x3f,0xf4,0x67,0x29,0x66,0x5b
};

#define test5_sha256_key test5_sha1_key
#define test5_md5_data test5_data
#define test5_sha1_data test5_data
#define test5_sha256_data test5_data
static const guint8 test5_md5_key[] = {
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c
};
static const guint8 test5_sha1_key[] = {
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
    0x0c,0x0c,0x0c,0x0c
};
static const guint8 test5_data[] = {
    'T', 'e', 's', 't', ' ', 'W', 'i', 't',
    'h', ' ', 'T', 'r', 'u', 'n', 'c', 'a',
    't', 'i', 'o', 'n'
};
static const guint8 test5_md5_output[] = {
    0x56,0x46,0x1e,0xf2,0x34,0x2e,0xdc,0x00,
    0xf9,0xba,0xb9,0x95,0x69,0x0e,0xfd,0x4c
};
static const guint8 test5_sha1_output[] = {
    0x4c,0x1a,0x03,0x42,0x4b,0x55,0xe0,0x7f,
    0xe7,0xf2,0x7b,0xe1,0xd5,0x8b,0xb9,0x32,
    0x4a,0x9a,0x5a,0x04
};
static const guint8 test5_sha256_output[] = {
    0xa3,0xb6,0x16,0x74,0x73,0x10,0x0e,0xe0,
    0x6e,0x0c,0x79,0x6c,0x29,0x55,0x55,0x2b,
    /* We don't actually truncate anything, here is the rest: */
    0xfa,0x6f,0x7c,0x0a,0x6a,0x8a,0xef,0x8b,
    0x93,0xf8,0x60,0xaa,0xb0,0xcd,0x20,0xc5
};

#define test6_md5_key test6_key
#define test6_sha1_key test6_key
#define test6_md5_data test6_data
#define test6_sha1_data test6_data
#define test6_sha256_data test6_data
static const guint8 test6_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa
};
static const guint8 test6_sha256_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa
};
static const guint8 test6_data[] = {
    'T', 'e', 's', 't', ' ', 'U', 's', 'i',
    'n', 'g', ' ', 'L', 'a', 'r', 'g', 'e',
    'r', ' ', 'T', 'h', 'a', 'n', ' ', 'B',
    'l', 'o', 'c', 'k', '-', 'S', 'i', 'z',
    'e', ' ', 'K', 'e', 'y', ' ', '-', ' ',
    'H', 'a', 's', 'h', ' ', 'K', 'e', 'y',
    ' ', 'F', 'i', 'r', 's', 't'
};
static const guint8 test6_md5_output[] = {
    0x6b,0x1a,0xb7,0xfe,0x4b,0xd7,0xbf,0x8f,
    0x0b,0x62,0xe6,0xce,0x61,0xb9,0xd0,0xcd
};
static const guint8 test6_sha1_output[] = {
    0xaa,0x4a,0xe5,0xe1,0x52,0x72,0xd0,0x0e,
    0x95,0x70,0x56,0x37,0xce,0x8a,0x3b,0x55,
    0xed,0x40,0x21,0x12
};
static const guint8 test6_sha256_output[] = {
    0x60,0xe4,0x31,0x59,0x1e,0xe0,0xb6,0x7f,
    0x0d,0x8a,0x26,0xaa,0xcb,0xf5,0xb7,0x7f,
    0x8e,0x0b,0xc6,0x21,0x37,0x28,0xc5,0x14,
    0x05,0x46,0x04,0x0f,0x0e,0xe3,0x7f,0x54
};

#define test7_md5_key test7_key
#define test7_sha1_key test7_key
#define test7_md5_data test7_data
#define test7_sha1_data test7_data
static const guint8 test7_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa
};
static const guint8 test7_sha256_key[] = {
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
    0xaa,0xaa,0xaa
};
static const guint8 test7_data[] = {
    'T', 'e', 's', 't', ' ', 'U', 's', 'i',
    'n', 'g', ' ', 'L', 'a', 'r', 'g', 'e',
    'r', ' ', 'T', 'h', 'a', 'n', ' ', 'B',
    'l', 'o', 'c', 'k', '-', 'S', 'i', 'z',
    'e', ' ', 'K', 'e', 'y', ' ', 'a', 'n',
    'd', ' ', 'L', 'a', 'r', 'g', 'e', 'r',
    ' ', 'T', 'h', 'a', 'n', ' ', 'O', 'n',
    'e', ' ', 'B', 'l', 'o', 'c', 'k', '-',
    'S', 'i', 'z', 'e', ' ', 'D', 'a', 't',
    'a'
};
static const guint8 test7_sha256_data[] = {
    'T', 'h', 'i', 's', ' ', 'i', 's', ' ',
    'a', ' ', 't', 'e', 's', 't', ' ', 'u',
    's', 'i', 'n', 'g', ' ', 'a', ' ', 'l',
    'a', 'r', 'g', 'e', 'r', ' ', 't', 'h',
    'a', 'n', ' ', 'b', 'l', 'o', 'c', 'k',
    '-', 's', 'i', 'z', 'e', ' ', 'k', 'e',
    'y', ' ', 'a', 'n', 'd', ' ', 'a', ' ',
    'l', 'a', 'r', 'g', 'e', 'r', ' ', 't',
    'h', 'a', 'n', ' ', 'b', 'l', 'o', 'c',
    'k', '-', 's', 'i', 'z', 'e', ' ', 'd',
    'a', 't', 'a', '.', ' ', 'T', 'h', 'e',
    ' ', 'k', 'e', 'y', ' ', 'n', 'e', 'e',
    'd', 's', ' ', 't', 'o', ' ', 'b', 'e',
    ' ', 'h', 'a', 's', 'h', 'e', 'd', ' ',
    'b', 'e', 'f', 'o', 'r', 'e', ' ', 'b',
    'e', 'i', 'n', 'g', ' ', 'u', 's', 'e',
    'd', ' ', 'b', 'y', ' ', 't', 'h', 'e',
    ' ', 'H', 'M', 'A', 'C', ' ', 'a', 'l',
    'g', 'o', 'r', 'i', 't', 'h', 'm', '.'
};
static const guint8 test7_md5_output[] = {
    0x6f,0x63,0x0f,0xad,0x67,0xcd,0xa0,0xee,
    0x1f,0xb1,0xf5,0x62,0xdb,0x3a,0xa5,0x3e
};
static const guint8 test7_sha1_output[] = {
    0xe8,0xe9,0x9d,0x0f,0x45,0x23,0x7d,0x78,
    0x6d,0x6b,0xba,0xa7,0x96,0x5c,0x78,0x08,
    0xbb,0xff,0x1a,0x91
};
static const guint8 test7_sha256_output[] = {
    0x9b,0x09,0xff,0xa7,0x1b,0x94,0x2f,0xcb,
    0x27,0x63,0x5f,0xbc,0xd5,0xb0,0xe9,0x44,
    0xbf,0xdc,0x63,0x64,0x4f,0x07,0x13,0x93,
    0x8a,0x7f,0x51,0x53,0x5c,0x3a,0x35,0xe2
};

/* Test vectors from https://tools.ietf.org/rfc/rfc4231.txt */

static
void
test_basic(
    void)
{
    FoilHmac* hmac = foil_hmac_new(FOIL_DIGEST_MD5, NULL, 0);
    g_assert(!foil_hmac_new(G_TYPE_OBJECT, NULL, 0));
    g_assert(!foil_hmac_new(0, NULL, 0));
    g_assert(!foil_hmac_clone(NULL));
    g_assert(!foil_hmac_ref(NULL));
    g_assert(!foil_hmac_finish(NULL));
    g_assert(!foil_hmac_free_to_bytes(NULL));
    foil_hmac_copy(NULL, NULL);
    foil_hmac_update(NULL, NULL, 0);
    foil_hmac_unref(NULL);
    foil_hmac_unref(foil_hmac_ref(hmac));
    foil_hmac_unref(hmac);
}

static
void
test_clone(
    void)
{
    FoilBytes key = { TEST_ARRAY_AND_SIZE(test1_md5_key) };
    FoilBytes data = { TEST_ARRAY_AND_SIZE(test1_md5_data) };
    FoilBytes output = { TEST_ARRAY_AND_SIZE(test1_md5_output) };
    FoilHmac* h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    FoilHmac* h2 = foil_hmac_clone(h1);
    GBytes* b1;
    GBytes* b2;

    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    b1 = foil_hmac_free_to_bytes(h1);
    b2 = foil_hmac_free_to_bytes(h2);
    g_assert(test_bytes_equal(b1, output.val, output.len));
    g_assert(test_bytes_equal(b2, output.val, output.len));

    g_bytes_unref(b1);
    g_bytes_unref(b2);

    /* Clone updated HMAC */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    foil_hmac_update(h1, data.val, data.len);
    h2 = foil_hmac_clone(h1);
    b1 = foil_hmac_free_to_bytes(h1);
    b2 = foil_hmac_free_to_bytes(h2);
    g_assert(test_bytes_equal(b1, output.val, output.len));
    g_assert(test_bytes_equal(b2, output.val, output.len));

    g_bytes_unref(b1);
    g_bytes_unref(b2);

    /* Clone finished HMAC */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    foil_hmac_update(h1, data.val, data.len);
    b1 = foil_hmac_finish(h1);
    h2 = foil_hmac_clone(h1);
    b2 = foil_hmac_free_to_bytes(h2);
    g_assert(test_bytes_equal(b1, output.val, output.len));
    g_assert(test_bytes_equal(b2, output.val, output.len));

    foil_hmac_unref(h1);
    g_bytes_unref(b2);
}

static
void
test_copy(
    void)
{
    FoilBytes key = { TEST_ARRAY_AND_SIZE(test1_md5_key) };
    FoilBytes key2 = { TEST_ARRAY_AND_SIZE(test2_md5_key) };
    FoilBytes data = { TEST_ARRAY_AND_SIZE(test1_md5_data) };
    FoilBytes md5_output = { TEST_ARRAY_AND_SIZE(test1_md5_output) };
    FoilHmac* h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    FoilHmac* h2 = foil_hmac_new(FOIL_DIGEST_SHA1, key.val, key.len);
    GBytes* b1;
    GBytes* b2;

    /* Copy unfinished HMACs */
    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    foil_hmac_copy(h2, NULL);
    foil_hmac_copy(h2, h2);
    foil_hmac_copy(h2, h1);

    b1 = foil_hmac_free_to_bytes(h1);
    b2 = foil_hmac_free_to_bytes(h2);
    g_assert(test_bytes_equal(b1, md5_output.val, md5_output.len));
    g_assert(test_bytes_equal(b2, md5_output.val, md5_output.len));

    g_bytes_unref(b1);
    g_bytes_unref(b2);

    /* Two unfinished HMACs with the same digest */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    h2 = foil_hmac_new(FOIL_DIGEST_MD5, key2.val, key2.len);
    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    foil_hmac_copy(h2, h1);

    b1 = foil_hmac_free_to_bytes(h1);
    b2 = foil_hmac_free_to_bytes(h2);
    g_assert(test_bytes_equal(b1, md5_output.val, md5_output.len));
    g_assert(test_bytes_equal(b2, md5_output.val, md5_output.len));

    g_bytes_unref(b1);
    g_bytes_unref(b2);

    /* One finished and one not */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    h2 = foil_hmac_new(FOIL_DIGEST_SHA1, key.val, key.len);
    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    b1 = foil_hmac_finish(h1);
    foil_hmac_copy(h2, h1);
    b2 = foil_hmac_finish(h2);
    g_assert(test_bytes_equal(b1, md5_output.val, md5_output.len));
    g_assert(test_bytes_equal(b2, md5_output.val, md5_output.len));

    foil_hmac_unref(h1);
    foil_hmac_unref(h2);

    /* Same thing but the other way around */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    h2 = foil_hmac_new(FOIL_DIGEST_SHA1, key.val, key.len);
    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    b2 = foil_hmac_finish(h2);
    g_bytes_ref(b2);
    foil_hmac_copy(h2, h1);
    b1 = foil_hmac_finish(h1);
    g_assert(foil_hmac_finish(h2) != b2);
    g_bytes_unref(b2);
    b2 = foil_hmac_finish(h2);
    g_assert(test_bytes_equal(b1, md5_output.val, md5_output.len));
    g_assert(test_bytes_equal(b2, md5_output.val, md5_output.len));

    foil_hmac_unref(h1);
    foil_hmac_unref(h2);

    /* Both are finished */
    h1 = foil_hmac_new(FOIL_DIGEST_MD5, key.val, key.len);
    h2 = foil_hmac_new(FOIL_DIGEST_SHA1, key.val, key.len);
    foil_hmac_update(h1, data.val, data.len);
    foil_hmac_update(h2, data.val, data.len);
    b1 = foil_hmac_finish(h1);
    b2 = foil_hmac_finish(h2);
    foil_hmac_copy(h2, h1);
    g_assert(foil_hmac_finish(h1) == b1);
    g_assert(foil_hmac_finish(h2) == b1);
    b1 = foil_hmac_finish(h2);
    g_assert(test_bytes_equal(b1, md5_output.val, md5_output.len));

    foil_hmac_unref(h1);
    foil_hmac_unref(h2);
}

static
void
test_hmac(
    gconstpointer param)
{
    const TestHmac* test = param;
    GType type = test->digest_type();
    FoilHmac* hmac = foil_hmac_new(type, test->key.val, test->key.len);
    GBytes* result;
    gsize size = 0;
    gconstpointer data;

    foil_hmac_update(hmac, test->data.val, test->data.len);
    result = foil_hmac_finish(hmac);
    data = g_bytes_get_data(result, &size);

    g_assert(size == test->output.len);
    g_assert(foil_digest_type_size(type) == test->output.len);
    g_assert(!memcmp(data, test->output.val, size));
    g_assert(foil_hmac_finish(hmac) == result);
    foil_hmac_unref(hmac);
}

/* Test descriptors */

#define TEST_NAME(name) "/hmac/" name
#define TEST_CASE_(i,md) { \
    TEST_NAME("Test" #i "/" #md), \
    foil_impl_digest_##md##_get_type, \
    {TEST_ARRAY_AND_SIZE(test##i##_##md##_key) }, \
    {TEST_ARRAY_AND_SIZE(test##i##_##md##_data) }, \
    {TEST_ARRAY_AND_SIZE(test##i##_##md##_output) }}
#define TEST_CASE(i) \
    TEST_CASE_(i,md5), \
    TEST_CASE_(i,sha1), \
    TEST_CASE_(i,sha256)

static const TestHmac tests[] = {
    TEST_CASE(1),
    TEST_CASE(2),
    TEST_CASE(3),
    TEST_CASE(4),
    TEST_CASE(5),
    TEST_CASE(6),
    TEST_CASE(7)
};

int main(int argc, char* argv[])
{
    guint i;
    g_test_init(&argc, &argv, NULL);
    g_test_add_func(TEST_NAME("Basic"), test_basic);
    g_test_add_func(TEST_NAME("Clone"), test_clone);
    g_test_add_func(TEST_NAME("Copy"), test_copy);
    for (i = 0; i < G_N_ELEMENTS(tests); i++) {
        g_test_add_data_func(tests[i].name, tests + i, test_hmac);
    }
    return test_run();
}

/*
 * Local Variables:
 * mode: C
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 */
